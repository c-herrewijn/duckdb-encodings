import sys
import os
import re

python_icu_encoding_map = [('ascii', '646', None, 'solaris-646-2.7.ucm'), ('big5', 'big5', None, 'aix-big5-4.3.6.ucm'), ('cp037', 'IBM037', None, 'glibc-IBM037-2.1.2.ucm'), ('cp273', 'IBM273', None, 'glibc-IBM273-2.1.2.ucm'), ('cp424', 'IBM424', None, 'glibc-IBM424-2.1.2.ucm'), ('cp437', 'IBM437', None, 'glibc-IBM437-2.1.2.ucm'), ('cp500', 'IBM500', None, 'glibc-IBM500-2.1.2.ucm'), ('cp850', 'IBM850', None, 'glibc-IBM850-2.1.2.ucm'), ('cp852', 'IBM852', None, 'glibc-IBM852-2.1.2.ucm'), ('cp855', 'IBM855', None, 'glibc-IBM855-2.1.2.ucm'), ('cp857', 'IBM857', None, 'glibc-IBM857-2.1.2.ucm'), ('cp860', 'IBM860', None, 'glibc-IBM860-2.1.2.ucm'), ('cp861', 'IBM861', None, 'glibc-IBM861-2.1.2.ucm'), ('cp862', 'IBM862', None, 'glibc-IBM862-2.1.2.ucm'), ('cp863', 'IBM863', None, 'glibc-IBM863-2.1.2.ucm'), ('cp864', 'IBM864', None, 'glibc-IBM864-2.1.2.ucm'), ('cp865', 'IBM865', None, 'glibc-IBM865-2.1.2.ucm'), ('cp866', 'IBM866', None, 'glibc-IBM866-2.1.2.ucm'), ('cp869', 'IBM869', None, 'glibc-IBM869-2.1.2.ucm'), ('cp949', 'UHC', None, 'glibc-UHC-2.1.2.ucm'), ('cp1026', 'IBM1026', None, 'glibc-IBM1026-2.1.2.ucm'), ('euc_jp', 'eucJP', None, 'solaris-eucJP-2.7.ucm'), ('gb18030', 'gb18030', None, 'gb-18030-2005.ucm'), ('mac_roman', 'MACINTOSH', None, 'glibc-MACINTOSH-2.1.2.ucm'), ('shift_jis', 'SJIS', None, 'glibc-SJIS-2.1.2.ucm')]

# python_icu_encoding_map = [('ascii', '646', None, 'solaris-646-2.7.ucm')]


footer_encoding_generted = '''} // namespace duckdb_encodings
} //namespace duckdb
'''

registration_class_header_1 = '''//===----------------------------------------------------------------------===//
//
//                         DuckDB - Encodings
//
// generated/registration.hpp
//
//
//===----------------------------------------------------------------------===//

// !!!!!!!
// WARNING: this file is autogenerated by scripts/converter.py, manual changes will be overwritten
// !!!!!!!

#pragma once

''' 

registration_class_header_2 = '''
namespace duckdb {
namespace duckdb_encodings {
class RegistrationEncodedFunctions {
public:
    static void RegisterFunctions(const DBConfig &config) {
'''

registration_class_footer = '''
    }
};
} // namespace duckdb_encodings
} // namespace duckdb

'''

sqltest_header = '''# name: test/sql/encodings.test
# description: test encodings extension, WARNING: This test is auto-generated by scripts/converter.py
# group: [encodings]

require encodings

'''

def unicode_to_utf8_bytes(codepoint: int) -> list[int]:
    """Convert a Unicode codepoint to a list of UTF-8 bytes."""
    return list(chr(codepoint).encode("utf-8"))

def parse_ucm_to_utf8_map(ucm_path):
    codepage_to_utf8 = {}
    max_utf8_len = 0

    with open(ucm_path, 'r', encoding='utf-8') as f:
        in_charmap = False
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            if line == 'CHARMAP':
                in_charmap = True
                continue
            if line.startswith('END CHARMAP'):
                break
            if not in_charmap:
                continue

            # Match: <UXXXX>  \xYY |0
            match = re.match(r'<U([0-9A-Fa-f]+)>\s+((?:\\x[0-9A-Fa-f]{2})+)\s+\|\d+', line)
            if not match:
                continue

            unicode_scalar = int(match.group(1), 16)
            byte_seq = bytes(int(b[2:], 16) for b in re.findall(r'\\x[0-9A-Fa-f]{2}', match.group(2)))

            utf8_encoded = chr(unicode_scalar).encode('utf-8')
            codepage_to_utf8[byte_seq] = utf8_encoded

    return codepage_to_utf8

def generate_cpp_map(encoding_name, codepage_to_utf8, filepath):
    lines = [f'// Generated from: {filepath}',
        f'const map<vector<uint8_t>, vector<uint8_t>> {encoding_name}_to_utf8 ='+' {'
    ]

    for cp_bytes, utf8_bytes in sorted(codepage_to_utf8.items()):
        cp_str = ', '.join(f'0x{b:02X}' for b in cp_bytes)
        utf8_str = ', '.join(f'0x{b:02X}' for b in utf8_bytes)
        lines.append(f'    {{ {{ {cp_str} }}, {{ {utf8_str} }} }},')

    lines.append('};')
    return '\n'.join(lines)


def generate_decoded_chars(python_icu_encoding_map, output_dir="data"):
    os.makedirs(output_dir, exist_ok=True)

    for encoding in python_icu_encoding_map:
        print(f"Generating for {encoding} (max {max_len} bytes)")
        path = os.path.join(output_dir, f"{encoding}.txt")
        seen = set()

        with open(path, "w", encoding="utf-8") as f_out:
            for byte_len in range(1, max_len + 1):
                for byte_seq in product(range(256), repeat=byte_len):
                    b = bytes(byte_seq)
                    try:
                        decoded = b.decode(encoding)
                        if decoded and decoded not in seen:
                            f_out.write(decoded + "\n")
                            seen.add(decoded)
                    except Exception:
                        continue

def write_utf8_representations_to_file(codepage_to_utf8, output_path):
    with open(output_path, 'w', encoding='utf-8') as f:
        for cp_bytes, utf8_bytes in sorted(codepage_to_utf8.items()):
            utf8_str = utf8_bytes.decode('utf-8')
            f.write(f"{utf8_str}\n")

generated_path = os.path.join('src','include','generated')
os.makedirs(generated_path, exist_ok=True)

with open(os.path.join(generated_path, 'registration.hpp'), "w", encoding="utf-8") as registration_file:
    registration_file.write(registration_class_header_1)
    for encoding in python_icu_encoding_map:
        registration_file.write(f'#include "{encoding[0]}_map.hpp"\n')
    registration_file.write(registration_class_header_2)

    with open(os.path.join('test','sql', 'encodings.test'), "w", encoding="utf-8") as sql_test:
        sql_test.write(sqltest_header)

        for encoding in python_icu_encoding_map:
            file_name = f'{encoding[0]}_map.hpp'
            header_encoding_generated = f'''//===----------------------------------------------------------------------===//
        //
        //                         DuckDB - Encodings
        //
        // generated/{file_name}
        //
        //
        //===----------------------------------------------------------------------===//

        // !!!!!!!
        // WARNING: this file is autogenerated by scripts/converter.py, manual changes will be overwritten
        // !!!!!!!

        #pragma once

        #include "duckdb/main/config.hpp"
        #include "duckdb/function/encoding_function.hpp"
        #include "generated_encoded_function.hpp"

        namespace duckdb {{
        namespace duckdb_encodings {{


        '''
            class_top = f'''class {encoding[0].capitalize()}ToUtf {{
        public:
            {encoding[0].capitalize()}ToUtf() {{}};
            const idx_t lookup_bytes = 1;
            const idx_t max_bytes_per_byte = 1;
            const string name = "{encoding[0]}";
            '''
            
            class_bottom = f'''
              static void Register(const DBConfig &config) {{
                const {encoding[0].capitalize()}ToUtf generated_function;
                const EncodingFunction function(generated_function.name, GeneratedEncodedFunction::Decode,
                                                generated_function.max_bytes_per_byte, generated_function.lookup_bytes,
                                                generated_function.{encoding[0]}_to_utf8);
                config.RegisterEncodeFunction(function);
            }}
        }};
        '''

            encoding_file_path = os.path.join('third_party','icu_encodings',encoding[3])
            bytemap = parse_ucm_to_utf8_map(encoding_file_path)
            registration_file.write(f'       {encoding[0].capitalize()}ToUtf::Register(config);\n')

            encoding_map_file_path = os.path.join(generated_path,file_name)
            with open(encoding_map_file_path, "w", encoding="utf-8") as out_file:
                # These are the matched encoding
                cpp_output = generate_cpp_map(encoding[0], bytemap, encoding[3])
                out_file.write(header_encoding_generated)
                out_file.write(class_top)
                out_file.write(cpp_output)
                out_file.write(class_bottom)
                out_file.write(footer_encoding_generted)
            # Write CSV Test
            test_file_path = os.path.join('data',f'test_{encoding[0]}.csv')
            write_utf8_representations_to_file(bytemap,test_file_path)
            sql_test_body = f'''statement ok
create or replace table T as FROM read_csv('{test_file_path}', encoding = '{encoding[0]}', header = 0, quote = '', auto_detect = false, columns = {{'a':'varchar'}}, delim = '', strict_mode = false)

'''
            sql_test.write(sql_test_body)
        registration_file.write(registration_class_footer)

